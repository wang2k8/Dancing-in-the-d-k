<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Dancing in the Dảk</title>
    <link rel="icon" type="image/png" href="icon.png">
    <style>
        @font-face {
            font-family: 'TF-Love-House';
            src: url('./TF-Love-House-j77u3e.otf') format('opentype');
        }
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: rgb(0, 0, 0);
            touch-action: none;
        }
        #info-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(255, 77, 77, 0.8), rgba(255, 255, 255, 0.3));
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            font-family: 'TF-Love-House', sans-serif;
            z-index: 1000;
        }
        #info-screen h1 {
            font-size: 2.5em;
            margin-bottom: 15px;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
        }
        #info-screen p {
            font-size: 1.2em;
            margin: 8px;
            text-shadow: 0 0 5px rgba(255, 77, 77, 0.8);
        }
        #start-button {
            padding: 10px 20px;
            font-size: 1.2em;
            background: #ff4d4d;
            color: white;
            border: 2px solid #ffffff;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 0 15px rgba(255, 77, 77, 0.7);
            font-family: 'TF-Love-House', sans-serif;
        }
        #start-button:hover {
            background: #ff4040;
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.9);
        }
        canvas {
            display: block;
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        #start-button {
            animation: pulse 3s infinite;
        }
    </style>
</head>
<body>
    <div id="info-screen">
        <h1>Dancing in the Dảk</h1>
        <p><strong>Máy tính:</strong></p>
        <p>Chuột: Xoay góc nhìn</p>
        <p>W/A/S/D: Di chuyển</p>
        <p>Space: Bay lên</p>
        <p>Shift: Bay xuống</p>
        <p>Ctrl: Tăng tốc độ</p>
        <p>ESC: Thoát</p>
        <p><strong>Điện thoại:</strong></p>
        <p>2 ngón zoom vào: Tiến lên</p>
        <p>2 ngón zoom ra: Lùi lại</p>
        <p>1 ngón vuốt lên/xuống: Lên/xuống</p>
        <p>1 ngón vuốt trái/phải: Sang trái/phải</p>
        <p>2 ngón vuốt: Xoay góc nhìn</p>
        <button id="start-button">Click</button>
    </div>
    <audio id="background-music" autoplay loop>
        <source src="phepmau.mp3" type="audio/mpeg">
        Your browser does not support the audio element.
    </audio>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/controls/PointerLockControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/loaders/FontLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/geometries/TextGeometry.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/postprocessing@6.23.2/build/postprocessing.min.js"></script>
    <script>
        let scene, camera, renderer, controls, composer;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false, moveUp = false, moveDown = false;
        let isCtrlPressed = false;
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        let prevTime = performance.now();
        let particles = [];
        let texts = [];
        let dustParticles = [];
        let imagePlanes = [];
        let isMobile = /Mobi|Android/i.test(navigator.userAgent);
        let touchStartX, touchStartY, touchStartDistance, pinchStartDistance;
        let isDragging = false, isPinching = false, isRotating = false;
        let lastParticleTime = 0;
        const romanticWords = ['What', 'Who', 'Where', 'When', 'Love', 'Forever', 'Always', 'Heart'];
        let font = null;
        let titleFont = null;
        const maxParticles = 500;
        const maxTexts = 500;
        const maxDustGroups = 300;
        const maxImages = 50;
        const imageFiles = ['anh1.jpg', 'anh2.jpg', 'anh3.jpg', 'anh4.jpg', 'anh5.jpg'];
        const initialLoadTime = performance.now();
        let dynamicLight;
        const maxDistance = 1000;
        const clearZone = 300;
        const blurStartDistance = 600;

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 0, 10);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.sortObjects = true;
            document.body.appendChild(renderer.domElement);

            composer = new POSTPROCESSING.EffectComposer(renderer);
            composer.addPass(new POSTPROCESSING.RenderPass(scene, camera));
            const dofEffect = new POSTPROCESSING.DepthOfFieldEffect(camera, {
                focalLength: 0.4,
                bokehScale: 1.5,
                height: window.innerHeight,
                focalDistance: 0.7
            });
            const bloomEffect = new POSTPROCESSING.BloomEffect({
                intensity: 2.0,
                luminanceThreshold: 0.4,
                luminanceSmoothing: 0.2
            });
            const effectPass = new POSTPROCESSING.EffectPass(camera, dofEffect, bloomEffect);
            composer.addPass(effectPass);

            const ambientLight = new THREE.AmbientLight(0x404040, 0.8);
            scene.add(ambientLight);

            dynamicLight = new THREE.PointLight(0xff6666, 2.5, 100, 2);
            dynamicLight.position.set(10, 10, 10);
            scene.add(dynamicLight);

            controls = new THREE.PointerLockControls(camera, renderer.domElement);
            controls.enabled = false;

            controls.addEventListener('unlock', () => {
                document.getElementById('info-screen').style.display = 'flex';
                controls.enabled = false;
            });

            const loader = new THREE.FontLoader();

            function createMainTexts() {
                const mainTexts = ['I', 'LOVE', 'YOU'];
                mainTexts.forEach((text, index) => {
                    const geometry = new THREE.TextGeometry(text, {
                        font: titleFont,
                        size: 6.4,
                        height: 0.32,
                        curveSegments: 12,
                        bevelEnabled: true,
                        bevelThickness: 0.176,
                        bevelSize: 0.132,
                        bevelOffset: 0,
                        bevelSegments: 5
                    });
                    const material = new THREE.MeshPhongMaterial({
                        color: Math.random() > 0.5 ? 0xff4d4d : 0xffffff,
                        emissive: Math.random() > 0.5 ? 0xff6666 : 0xaaaaaa,
                        emissiveIntensity: 1.0,
                        specular: 0x555555,
                        shininess: 50,
                        transparent: true
                    });
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.position.set(
                        camera.position.x + (Math.random() - 0.5) * 500,
                        camera.position.y + (Math.random() - 0.5) * 500,
                        camera.position.z + (Math.random() - 0.5) * 500
                    );
                    mesh.userData = { 
                        pulse: Math.random() * Math.PI * 2,
                        rotationSpeed: (Math.random() - 0.5) * 0.02,
                        velocity: new THREE.Vector3((Math.random() - 0.5) * 0.02, -0.05, (Math.random() - 0.5) * 0.02)
                    };
                    scene.add(mesh);
                    texts.push(mesh);
                });
            }

            loader.load('./KD-Yon-Love.ttf', function (loadedFont) {
                titleFont = loadedFont;
                createMainTexts();
            }, undefined, function (error) {
                console.error('Lỗi tải font KD-Yon-Love.ttf:', error);
                loader.load('https://threejs.org/examples/fonts/helvetiker_bold.typeface.json', function (loadedFont) {
                    titleFont = loadedFont;
                    createMainTexts();
                });
            });

            loader.load('https://threejs.org/examples/fonts/helvetiker_bold.typeface.json', function (loadedFont) {
                font = loadedFont;
            });

            const particleGeometry = new THREE.SphereGeometry(0.25, 16, 16);
            for (let i = 0; i < 50; i++) {
                const material = new THREE.MeshPhongMaterial({
                    color: Math.random() > 0.5 ? 0xff4d4d : 0xffffff,
                    emissive: Math.random() > 0.5 ? 0xff6666 : 0xaaaaaa,
                    emissiveIntensity: 1.2,
                    transparent: true,
                    opacity: 0.8,
                    specular: 0x555555,
                    shininess: 32
                });
                const particle = new THREE.Mesh(particleGeometry, material);
                particle.position.set(
                    camera.position.x + (Math.random() - 0.5) * 500,
                    camera.position.y + (Math.random() - 0.5) * 500,
                    camera.position.z + (Math.random() - 0.5) * 500
                );
                particle.userData = { 
                    velocity: new THREE.Vector3((Math.random() - 0.5) * 0.02, (Math.random() - 0.5) * 0.02, (Math.random() - 0.5) * 0.02),
                    pulse: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.02
                };
                scene.add(particle);
                particles.push(particle);
            }

            const dustGeometry = new THREE.BufferGeometry();
            const dustVertices = [];
            const dustCount = 800;
            for (let i = 0; i < dustCount; i++) {
                dustVertices.push(
                    camera.position.x + (Math.random() - 0.5) * 1000,
                    camera.position.y + (Math.random() - 0.5) * 1000,
                    camera.position.z + (Math.random() - 0.5) * 1000
                );
            }
            dustGeometry.setAttribute('position', new THREE.Float32BufferAttribute(dustVertices, 3));
            const dustMaterial = new THREE.PointsMaterial({
                color: Math.random() > 0.5 ? 0xffffff : 0xff6666,
                size: 0.4,
                map: new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/circle.png'),
                transparent: true,
                opacity: 1.2,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            const dust = new THREE.Points(dustGeometry, dustMaterial);
            scene.add(dust);
            dust.userData = {
                velocities: Array(dustCount).fill().map(() => new THREE.Vector3(
                    (Math.random() - 0.5) * 0.01,
                    -0.03,
                    (Math.random() - 0.5) * 0.01
                ))
            };
            dustParticles.push(dust);

            document.addEventListener('keydown', (event) => {
                if (event.ctrlKey && event.code !== 'ControlLeft' && event.code !== 'ControlRight') {
                    event.preventDefault();
                    event.stopPropagation();
                }
            }, { capture: true });

            window.addEventListener('beforeunload', (event) => {
                event.preventDefault();
                event.returnValue = '';
            });

            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.getElementById('start-button').addEventListener('click', startExperience);

            if (isMobile) {
                renderer.domElement.addEventListener('touchstart', onTouchStart);
                renderer.domElement.addEventListener('touchmove', onTouchMove);
                renderer.domElement.addEventListener('touchend', onTouchEnd);
            }

            window.addEventListener('resize', onWindowResize);
            animate();
        }

        function startExperience() {
            document.getElementById('info-screen').style.display = 'none';
            controls.enabled = true;
            if (!isMobile) {
                controls.lock();
            }
            const audio = document.getElementById('background-music');
            if (audio.paused) {
                audio.play().catch(error => console.error('Lỗi phát nhạc:', error));
            }
        }

        function onKeyDown(event) {
            switch (event.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyD': moveRight = true; break;
                case 'ShiftLeft': moveUp = true; break;
                case 'Space': moveDown = true; break;
                case 'ControlLeft':
                case 'ControlRight': isCtrlPressed = true; break;
                case 'Escape': controls.unlock(); break;
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyD': moveRight = false; break;
                case 'ShiftLeft': moveUp = false; break;
                case 'Space': moveDown = false; break;
                case 'ControlLeft':
                case 'ControlRight': isCtrlPressed = false; break;
            }
        }

        function onTouchStart(event) {
            event.preventDefault();
            if (event.touches.length === 1) {
                isDragging = true;
                touchStartX = event.touches[0].clientX;
                touchStartY = event.touches[0].clientY;
            } else if (event.touches.length === 2) {
                isDragging = false;
                isPinching = true;
                isRotating = true;
                const dx = event.touches[0].clientX - event.touches[1].clientX;
                const dy = event.touches[0].clientY - event.touches[1].clientY;
                touchStartDistance = Math.sqrt(dx * dx + dy * dy);
                pinchStartDistance = touchStartDistance;
                touchStartX = (event.touches[0].clientX + event.touches[1].clientX) / 2;
                touchStartY = (event.touches[0].clientY + event.touches[1].clientY) / 2;
            }
        }

        function onTouchMove(event) {
            event.preventDefault();
            if (event.touches.length === 1 && isDragging) {
                const touch = event.touches[0];
                const deltaX = touch.clientX - touchStartX;
                const deltaY = touch.clientY - touchStartY;
                const moveSpeed = 0.1;
                const right = new THREE.Vector3(deltaX, 0, 0).applyQuaternion(camera.quaternion);
                camera.position.add(right.multiplyScalar(moveSpeed));
                const up = new THREE.Vector3(0, -deltaY, 0);
                camera.position.add(up.multiplyScalar(moveSpeed));
                touchStartX = touch.clientX;
                touchStartY = touch.clientY;
            } else if (event.touches.length === 2 && (isPinching || isRotating)) {
                const dx = event.touches[0].clientX - event.touches[1].clientX;
                const dy = event.touches[0].clientY - event.touches[1].clientY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const newTouchX = (event.touches[0].clientX + event.touches[1].clientX) / 2;
                const newTouchY = (event.touches[0].clientY + event.touches[1].clientY) / 2;
                const deltaX = newTouchX - touchStartX;
                const deltaY = newTouchY - touchStartY;

                controls.getObject().rotation.y -= deltaX * 0.005;
                controls.getObject().rotation.x -= deltaY * 0.005;
                controls.getObject().rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, controls.getObject().rotation.x));

                const deltaPinch = distance - pinchStartDistance;
                const moveSpeed = 0.5;
                const forward = new THREE.Vector3(0, 0, -deltaPinch).applyQuaternion(camera.quaternion);
                camera.position.add(forward.multiplyScalar(moveSpeed));

                touchStartX = newTouchX;
                touchStartY = newTouchY;
                pinchStartDistance = distance;
            }
        }

        function onTouchEnd(event) {
            event.preventDefault();
            isDragging = false;
            isPinching = false;
            isRotating = false;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function spawnTextNearCamera() {
            if (!font || texts.length >= maxTexts) return;
            const text = romanticWords[Math.floor(Math.random() * romanticWords.length)];
            const geometry = new THREE.TextGeometry(text, {
                font: font,
                size: 4.0,
                height: 0.528,
                curveSegments: 12,
                bevelEnabled: true,
                bevelThickness: 0.132,
                bevelSize: 0.099,
                bevelOffset: 0,
                bevelSegments: 3
            });
            const material = new THREE.MeshPhongMaterial({
                color: Math.random() > 0.5 ? 0xff4d4d : 0xffffff,
                emissive: Math.random() > 0.5 ? 0xff6666 : 0xaaaaaa,
                emissiveIntensity: 0.7,
                specular: 0x555555,
                shininess: 50,
                transparent: true
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(
                camera.position.x + (Math.random() - 0.5) * 350,
                camera.position.y + (Math.random() - 0.5) * 350,
                camera.position.z + (Math.random() - 0.5) * 350
            );
            mesh.userData = { 
                velocity: new THREE.Vector3((Math.random() - 0.5) * 0.02, -0.05, (Math.random() - 0.5) * 0.02),
                pulse: Math.random() * Math.PI * 2,
                rotationSpeed: (Math.random() - 0.5) * 0.02
            };
            scene.add(mesh);
            texts.push(mesh);
        }

        function spawnParticleAtCamera() {
            if (particles.length >= maxParticles) return;
            const material = new THREE.MeshPhongMaterial({
                color: Math.random() > 0.5 ? 0xff4d4d : 0xffffff,
                emissive: Math.random() > 0.5 ? 0xff6666 : 0xaaaaaa,
                emissiveIntensity: 1.2,
                transparent: true,
                opacity: 0.8,
                specular: 0x555555,
                shininess: 30
            });
            const particle = new THREE.Mesh(new THREE.SphereGeometry(0.25, 16, 16), material);
            
            const radius = 100;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI;
            const x = radius * Math.sin(phi) * Math.cos(theta);
            const y = radius * Math.sin(phi) * Math.sin(theta);
            const z = radius * Math.cos(phi);
            
            particle.position.copy(camera.position);
            particle.position.add(new THREE.Vector3(x, y, z));
            particle.userData = { 
                velocity: new THREE.Vector3((Math.random() - 0.5) * 0.02, (Math.random() - 0.5) * 0.02, (Math.random() - 0.5) * 0.02),
                pulse: Math.random() * Math.PI * 2,
                rotationSpeed: (Math.random() - 0.5) * 0.02
            };
            scene.add(particle);
            particles.push(particle);
        }

        function spawnDustNearCamera() {
            if (dustParticles.length >= maxDustGroups) return;
            const dustGeometry = new THREE.BufferGeometry();
            const dustVertices = [];
            const dustCount = 800;
            for (let i = 0; i < dustCount; i++) {
                dustVertices.push(
                    camera.position.x + (Math.random() - 0.5) * 1000,
                    camera.position.y + (Math.random() - 0.5) * 1000,
                    camera.position.z + (Math.random() - 0.5) * 1000
                );
            }
            dustGeometry.setAttribute('position', new THREE.Float32BufferAttribute(dustVertices, 3));
            const dustMaterial = new THREE.PointsMaterial({
                color: Math.random() > 0.5 ? 0xffffff : 0xff6666,
                size: 0.4,
                map: new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/circle.png'),
                transparent: true,
                opacity: 1.2,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            const dust = new THREE.Points(dustGeometry, dustMaterial);
            scene.add(dust);
            dust.userData = {
                velocities: Array(dustCount).fill().map(() => new THREE.Vector3(
                    (Math.random() - 0.5) * 0.01,
                    -0.03,
                    (Math.random() - 0.5) * 0.01
                ))
            };
            dustParticles.push(dust);
        }

        function spawnImageNearCamera() {
            if (imagePlanes.length >= maxImages) return;
            const imageFile = imageFiles[Math.floor(Math.random() * imageFiles.length)];
            const texture = new THREE.TextureLoader().load(imageFile);
            const material = new THREE.MeshPhongMaterial({
                map: texture,
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide,
                emissive: Math.random() > 0.5 ? 0xff6666 : 0xaaaaaa,
                emissiveIntensity: 0.7,
                specular: 0x555555,
                shininess: 30
            });
            const geometry = new THREE.PlaneGeometry(5, 5);
            const imagePlane = new THREE.Mesh(geometry, material);
            
            const radius = 100;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI;
            const x = radius * Math.sin(phi) * Math.cos(theta);
            const y = radius * Math.sin(phi) * Math.sin(theta);
            const z = radius * Math.cos(phi);
            
            imagePlane.position.copy(camera.position);
            imagePlane.position.add(new THREE.Vector3(x, y, z));
            imagePlane.userData = { 
                velocity: new THREE.Vector3((Math.random() - 0.5) * 0.02, -0.05, (Math.random() - 0.5) * 0.02),
                pulse: Math.random() * Math.PI * 2,
                rotationSpeed: (Math.random() - 0.5) * 0.02
            };
            scene.add(imagePlane);
            imagePlanes.push(imagePlane);
        }

        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now();
            const delta = (time - prevTime) / 1000;

            dynamicLight.position.set(
                10 * Math.sin(time * 0.001),
                10 * Math.cos(time * 0.001),
                10 * Math.sin(time * 0.0005)
            );
            dynamicLight.intensity = 2.5 + Math.sin(time * 0.002) * 0.5;

            const isInitialLoad = time < initialLoadTime + 5000;
            const textSpawnChance = isInitialLoad ? 0.5 : 0.2;
            const dustSpawnChance = isInitialLoad ? 0.9 : 0.5;
            let textCount = 0;
            if (Math.random() < textSpawnChance && texts.length < maxTexts && textCount < 5) {
                spawnTextNearCamera();
                textCount++;
            }
            let particleCount = 0;
            if (((moveForward || moveBackward || moveLeft || moveRight || moveUp || moveDown) && time - lastParticleTime > 10) || Math.random() < 0.25) {
                if (particles.length < maxParticles && particleCount < 5) {
                    spawnParticleAtCamera();
                    lastParticleTime = time;
                    particleCount++;
                }
            }
            if (Math.random() < dustSpawnChance && dustParticles.length < maxDustGroups) {
                spawnDustNearCamera();
            }
            let imageCount = 0;
            if (Math.random() < 0.2 && imagePlanes.length < maxImages && imageCount < 3) {
                spawnImageNearCamera();
                imageCount++;
            }

            particles.forEach(particle => {
                particle.position.add(particle.userData.velocity);
                particle.rotation.x += particle.userData.rotationSpeed;
                particle.rotation.y += particle.userData.rotationSpeed;
                const pulse = Math.sin(time * 0.001 + particle.userData.pulse) * 0.2 + 0.8;
                const distance = particle.position.distanceTo(camera.position);
                const fadeFactor = distance < clearZone ? 1.0 : Math.max(0.1, Math.exp(-(distance - clearZone) / 300));
                particle.material.opacity = pulse * fadeFactor;
                if (distance > maxDistance || particle.position.y < camera.position.y - maxDistance) {
                    scene.remove(particle);
                    particles = particles.filter(p => p !== particle);
                }
            });

            texts.forEach(text => {
                text.position.add(text.userData.velocity);
                text.rotation.y += text.userData.rotationSpeed;
                const pulse = Math.sin(time * 0.001 + text.userData.pulse) * 0.2 + 0.8;
                const distance = text.position.distanceTo(camera.position);
                const fadeFactor = distance < clearZone ? 1.0 : Math.max(0.1, Math.exp(-(distance - clearZone) / 300));
                text.material.opacity = pulse * fadeFactor;
                if (distance > maxDistance || text.position.y < camera.position.y - maxDistance) {
                    scene.remove(text);
                    texts = texts.filter(t => t !== text);
                }
            });

            dustParticles = dustParticles.filter(dust => {
                const positions = dust.geometry.attributes.position.array;
                const velocities = dust.userData.velocities;
                let keep = false;
                for (let i = 0; i < positions.length; i += 3) {
                    positions[i] += velocities[i / 3].x;
                    positions[i + 1] += velocities[i / 3].y;
                    positions[i + 2] += velocities[i / 3].z;
                    const distance = new THREE.Vector3(positions[i], positions[i + 1], positions[i + 2]).distanceTo(camera.position);
                    if (distance <= maxDistance && positions[i + 1] > camera.position.y - maxDistance) {
                        keep = true;
                        const fadeFactor = distance < clearZone ? 1.0 : Math.max(0.1, Math.exp(-(distance - clearZone) / 300));
                        dust.material.opacity = 1.2 * fadeFactor;
                    }
                }
                dust.geometry.attributes.position.needsUpdate = true;
                dust.material.needsUpdate = true;
                if (!keep) {
                    scene.remove(dust);
                    return false;
                }
                return true;
            });

            imagePlanes.forEach(image => {
                image.position.add(image.userData.velocity);
                image.rotation.y += image.userData.rotationSpeed;
                image.rotation.z += image.userData.rotationSpeed * 0.5;
                const pulse = Math.sin(time * 0.001 + image.userData.pulse) * 0.2 + 0.8;
                const distance = image.position.distanceTo(camera.position);
                const fadeFactor = distance < clearZone ? 1.0 : Math.max(0.1, Math.exp(-(distance - clearZone) / 300));
                image.material.opacity = pulse * fadeFactor;
                if (distance > maxDistance || image.position.y < camera.position.y - maxDistance) {
                    scene.remove(image);
                    imagePlanes = imagePlanes.filter(img => img !== image);
                }
            });

            if (!isMobile) {
                velocity.x *= 0.9;
                velocity.y *= 0.9;
                velocity.z *= 0.9;

                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.y = Number(moveUp) - Number(moveDown);
                direction.normalize();

                if (moveForward || moveBackward) velocity.z -= direction.z * 400.0 * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * 400.0 * delta;
                if (moveUp || moveDown) velocity.y -= direction.y * 400.0 * delta;

                const speedMultiplier = isCtrlPressed ? 2.0 : 1.0;
                controls.moveRight(-velocity.x * delta * speedMultiplier);
                controls.moveForward(-velocity.z * delta * speedMultiplier);
                controls.getObject().position.y += velocity.y * delta * speedMultiplier;
            }

            composer.render();
            prevTime = time;
        }

        init();
    </script>
</body>
</html>
